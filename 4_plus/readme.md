进阶

#### 1. 引用

##### 1.1 基本使用

​	**作用: **给变量起别名；

​	语法：==数据类型 &别名 = 原名==

​	实例:

```c++
void reference_test1()
{
    using namespace std;
    cout << "基本使用" <<endl;
 
    int a = 10;
    int &b = a;
    
    cout << "a = "<<a <<endl;
    
    b = 100;
    cout << "a = "<<a <<endl;
    cout << "b = "<<b <<endl;
}  
```

##### 1.2 引用注意事项

- 引用必须初始化；
- 应用在初始化后，不可以改变；

##### 1.3 引用做函数参数

- 函数传参时，可以利用引用的技术让星灿修饰实参
- 简化指针修改实参

```c++
//1. 值传递
void mySwap01(int a, int b) {
	int temp = a;
	a = b;
	b = temp;
}

//2. 地址传递
void mySwap02(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}

//3. 引用传递
void mySwap03(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}

int main() {

	int a = 10;
	int b = 20;

	mySwap01(a, b);
	cout << "a:" << a << " b:" << b << endl;

	mySwap02(&a, &b);
	cout << "a:" << a << " b:" << b << endl;

	mySwap03(a, b);
	cout << "a:" << a << " b:" << b << endl;

	system("pause");

	return 0;
}
```

##### 2.4 引用做函数返回值

作用：引用可以作为函数的返回值存在

注意：不要返回局部变量引用

用法：函数调用作为左值

```c++
//返回局部变量引用
int& test01() {
	int a = 10; //局部变量
	return a;
}

//返回静态变量引用
int& test02() {
	static int a = 20;
	return a;
}

int main() {

	//不能返回局部变量的引用,出错！
	int& ref = test01();
	cout << "ref = " << ref << endl;
	cout << "ref = " << ref << endl;

	//如果函数做左值，那么必须返回引用
	int& ref2 = test02();
	cout << "ref2 = " << ref2 << endl;
	cout << "ref2 = " << ref2 << endl;

	test02() = 1000;

	cout << "ref2 = " << ref2 << endl;
	cout << "ref2 = " << ref2 << endl;

	system("pause");

	return 0;
}
```

#### 2. 类和对象

C++面向对象的三大特性为：**封装、集成、多态**

C++认为万事万物皆为对象，对象上有起属性和属性和行为；

##### 2.1 封装

访问权限控制：

1. public：公共权限                //类内可以访问，类外可以访问
2. protected：保护权限         //类内可以访问，类外不可以访问
3. private：所有权限             //类内可以访问，类外不可以访问

class默认权限为私有，struct默认权限为公共；

##### 2.2 对象的初始化和清理

C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。

###### 2.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

 一个对象或者变量没有初始状态，对其使用后果是未知

 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

c++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**.

**编译器提供的构造函数和析构函数是空实现。**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 可以讲堆区开辟的数据做释放操作。
4. 构造函数可以有参数，因此可以发生重载
5. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号 ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

###### 4.2.2 构造函数的分类及调用

两种分类方式：

按参数分为： 有参构造和无参构造（默认构造函数）

按类型分为： 普通构造和拷贝构造

三种调用方式：括号法、显示法、隐式转换法

```c++
Person p1;		//调用无参构造函数
//括号法
Person p1(10);  //调用有参构造函数
//Person p1(p) 错误！！！！！
//显式法
Person p2 = Person(10);		//调用有参构造函数
Person p3 = Person(p2);		//调用拷贝构造函数
//隐式法
Person p4 = 10;
Person p5 = p4;
```

###### 2.2.3 拷贝构造函数调用实际

- 使用一个已经创建完毕的对象来初始化新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

###### 2.2.4 深拷贝和浅拷贝

- 浅拷贝：简单的赋值拷贝操作；
- 在堆区重新申请空间，进行拷贝操作

问题：浅拷贝（默认拷贝构造函数）带来的问题就是堆区的内存重复释放。

解决：重新申请新指针。自定义拷贝构造函数。

###### 2.2.4 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - ==类内声明，类外初始化==
- 静态成员函数
  - 所有对象共享同一个函数
  - 静态成员函数只能访问静态成员变量

##### 2.3. C++对象模型和this指针

###### 2.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

###### 2.3.2

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**

this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用return *this


